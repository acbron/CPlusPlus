				条款32：确定你的public集成塑模出is-a关系
			Make sure public inheritance models "is-a"
	如果你令class D(Derived)以public形式继承class B(Base)，你便是告诉C++编译器(以及你的代码读者)说，每一个类型为D的对象同时也是一个类型为B的对象，反之不成立。即class B为一般化的，而D是特殊化的。
	is-a意味着base class身上的每一件事一定也适用于derived class身上。



				条款33：避免遮掩继承而来的名称
			Avoid hiding inherited names
	变量的作用域(scopes)中，如果有
int x;
void someFunc()
{
	double x;
	std::cin >> x;
}
global变量int x会被local变量double x遮掩。这是C++的名称遮掩规则(name-hidig rules)干的。其查找规则是一层一层往上找，找到即止。同理，考虑继承体系中，有
class Base{
	public:
		virtual void f1() = 0;
		virtual void f1(int x);
		...
};
class Derived:public Base{
	virtual void f1();
	...
};
则如果有一个Derived d对象，d.f1()调用的是Derived那个版本，而d.f1(3)却会编译不通过，这是因为Base上的所有重载的f1都被Derived遮掩了！考虑到is-a关系，这决不允许在public继承里发生！解决方法是：
(1)在Derived class的public里使用声明式
class Derived:public Base{
	using Base::f1;
	virtual void f1();
	...
};
(2)使用转交函数(forwarding functions)
class Derived:public Base{
	virtual void f1();
	virtual void f1(int x)
	{
		Base::f1(x);
	}
	...
};



				条款34：区分接口继承和实现继承
			Differentiate between inheritance of interface and inheritance of implementation.
	public继承由两部分组成：函数接口(function interfaces)继承和函数实现(function implementations)继承。
	有三种你可能会希望的继承方式：
(1)只继承成员函数的接口
(2)同时继承函数的接口和实现，但又希望能够覆写(override)它们所继承的实现
(3)同时继承函数的接口和实现，但不允许覆写。
考虑如下代码：
class Shape {
	public:
		virtual void draw() const = 0;
		virtual void error(const std::string &msg);
		int objectID() const;
		...
};
class Rectangle:public Shape { ... };
class Ellipse:public Shape { ... };
	首先，由于draw()这个pure virtual函数的存在，所以Shape是一个抽象类，无法创建该类的实体。
	(1)声明pure virtual函数的目的是为了让derived class只继承函数接口，这是告诉设计该类的derived类的人，必须提供一个draw()函数
	(2)声明impure virtual函数的目的是让derived class继承该函数的接口和缺省实现。比如error()，derived class可以自己实现该函数，也可以使用Shape提供的缺省版本
	但允许impure virtual函数同时指定函数声明和函数缺省行为可能会导致危险。比如virtual函数的缺省行为不是新增derived class所需要的行为，而新增derived class又未重新定义该函数。这时有两种做法：
	1.将virtual函数声明为pure，只提供接口，然后在protected里实现缺省行为。这样就切断了virtual函数接口和缺省实现之间的连接。这样，需要缺省行为的derived class里，只需要对protected里的缺省行为进行inline调用，像这样
	virtual void fly(const Airport &destination){ 
		defaultFly(destination); //详细代码查阅《Effective C++,3rd》P161
	}
这样便强制新derived class设计者对pure virtual函数进行重新实现了。
	2.在base class里对pure virtual函数提供一份实现，这样在需要缺省行为的derived class里只需明确申请，就可以使用缺省行为了，像这样
	virtual void fly(const Airport &destination){
		Airplane::fly(destination) //Airplane是base class
	}
但是，这样一来，原本为protected的函数便成了public。两种方法视情况而定。
	(3)声明non-virtual函数的目的是为了令derived class继承函数的接口以及一份强制性的实现。
