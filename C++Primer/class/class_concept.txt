<1>类的定义和声明
1.类的概念
-最简单地说，类就是定义了一个新的类型和一个新的作用域。
-类可以没有成员，也可以有多个成员。成员可以是数据，函数或类型别名(typedef)
-在类内部定义的函数默认为inline。也可以显式地在类内部声明inline函数，或者在类外部的定义部分声明为inline。inline函数必须在调用该函数的每个源文件中可见，因此inline成员函数定义通常放在类定义的同一头文件中。
-const成员函数声明为:int func()const;即这个成员函数声明为常量，意味着这个成员函数不能改变其所操作对象的数据成员。const必须同时出现在声明和定义中，否则会编译错误。

2.数据抽象和封装
-数据抽象和封装是类的基本思想
-数据抽象是一种依赖于接口和实现分离的编程（设计）技术。
-封装是一项将低层次的元素组合起来形成新的，高层次实体的技术。其关键在于隐藏实现的细节。
-访问标号实现的抽象和封装：public,private,protected。这些访问标号出现的次数是不限的。
-以struct定义类，则第一个访问标号之前的成员默认为public，以class定义类，则默认为private
-数据抽象和封装的好处：（1）避免类内部出现无意的，可能破坏对象状态的用户级错误。（2）随时间推移可以根据需求改变或缺陷报告来完善类实现，而无需改动用户级代码。

3.类声明与类定义
-类声明而未定义，称之为前向声明(forward declaration)，是一个不完全类型(incompete type)。
-不完全类型不能定义其对象，只能用于定义指向该类型的指针或引用，以及声明使用该类型作为形参或返回类型的函数。
-只有在定义类类型对象时，编译器才会分配内存空间。

4.this指针
-指向类对象的指针，与调用成员函数的对象绑定在一起。
-在成员函数内部通常不必显式引用this，但有时候需要返回对this指针的引用（比如链式表达式a.f1().f2()）。
-this指针实质上是一个const指针，它可以改变其所指向的值，但它本身保存的地址无法改变。
-从const成员函数返回this指针遇到的问题：假如const成员函数cf()，类对象a，则a.cf().f1()编译无法通过。原因是cf()返回的是一个const对象，但却调用了非const成员函数f1()。f1()可能需要修改对象的数据成员。解决方法是重载const成员函数
className& cf() { do_cf(); }
const className& cf()const { do_cf(); }
通过一个实现函数，让两个版本的cf()调用它，避免代码重复
returnType do_cf();
-可以将数据成员声明为mutable来实现可变数据成员。mutable成员永远都不可能是const，即使它是const对象的成员。const成员函数也可以修改它。

5.类作用域
-类成员声明的名字查找：先检查出现在名字使用之前的类成员声明；否则检查包含类定义的作用域中出现的声明以及出现在类定义之前的声明；
-类成员定义中的名字查找：先检查成员函数局部作用域中的声明；然后再查找类成员中的声明；最后查找在此成员函数定义之前的声明；


